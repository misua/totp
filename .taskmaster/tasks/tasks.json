{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Terraform Project Structure",
        "description": "Set up the basic Terraform project structure with provider configuration and state management for AWS resources.",
        "details": "Create the following files:\n1. `main.tf` - Main configuration file\n2. `variables.tf` - Variable declarations\n3. `outputs.tf` - Output definitions\n4. `providers.tf` - AWS provider configuration\n\nIn providers.tf:\n```hcl\nprovider \"aws\" {\n  region = var.aws_region\n}\n\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 4.0\"\n    }\n  }\n  required_version = \">= 1.0.0\"\n}\n```\n\nIn variables.tf, define basic variables:\n```hcl\nvariable \"aws_region\" {\n  description = \"AWS region to deploy resources\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"project_name\" {\n  description = \"Name of the project for resource tagging\"\n  type        = string\n  default     = \"aws-terraform-poc\"\n}\n```",
        "testStrategy": "Verify the project structure by running `terraform init` to ensure provider plugins are downloaded correctly and the configuration is valid. Check for any initialization errors.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create VPC with Public and Private Subnets",
        "description": "Set up the AWS VPC with public and private subnets across multiple availability zones for high availability.",
        "details": "Create a new file `network.tf` with the following resources:\n\n```hcl\n# VPC\nresource \"aws_vpc\" \"main\" {\n  cidr_block           = \"10.0.0.0/16\"\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n  tags = {\n    Name = \"${var.project_name}-vpc\"\n  }\n}\n\n# Public Subnets\nresource \"aws_subnet\" \"public\" {\n  count                   = 2\n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = \"10.0.${count.index}.0/24\"\n  availability_zone       = data.aws_availability_zones.available.names[count.index]\n  map_public_ip_on_launch = true\n  tags = {\n    Name = \"${var.project_name}-public-${count.index}\"\n  }\n}\n\n# Private Subnets\nresource \"aws_subnet\" \"private\" {\n  count             = 2\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = \"10.0.${count.index + 10}.0/24\"\n  availability_zone = data.aws_availability_zones.available.names[count.index]\n  tags = {\n    Name = \"${var.project_name}-private-${count.index}\"\n  }\n}\n\n# Internet Gateway\nresource \"aws_internet_gateway\" \"main\" {\n  vpc_id = aws_vpc.main.id\n  tags = {\n    Name = \"${var.project_name}-igw\"\n  }\n}\n\n# Public Route Table\nresource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.main.id\n  tags = {\n    Name = \"${var.project_name}-public-rt\"\n  }\n}\n\n# Public Route\nresource \"aws_route\" \"public_internet_gateway\" {\n  route_table_id         = aws_route_table.public.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  gateway_id             = aws_internet_gateway.main.id\n}\n\n# Public Route Table Association\nresource \"aws_route_table_association\" \"public\" {\n  count          = 2\n  subnet_id      = aws_subnet.public[count.index].id\n  route_table_id = aws_route_table.public.id\n}\n\n# Private Route Table\nresource \"aws_route_table\" \"private\" {\n  vpc_id = aws_vpc.main.id\n  tags = {\n    Name = \"${var.project_name}-private-rt\"\n  }\n}\n\n# Private Route Table Association\nresource \"aws_route_table_association\" \"private\" {\n  count          = 2\n  subnet_id      = aws_subnet.private[count.index].id\n  route_table_id = aws_route_table.private.id\n}\n\n# Get available AZs\ndata \"aws_availability_zones\" \"available\" {}\n```\n\nAdd the following variables to variables.tf:\n```hcl\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for the VPC\"\n  type        = string\n  default     = \"10.0.0.0/16\"\n}\n```",
        "testStrategy": "Run `terraform plan` to verify the network configuration. Check that the VPC, subnets, internet gateway, and route tables are correctly defined. Verify CIDR blocks don't overlap and that public subnets have the map_public_ip_on_launch attribute set to true.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Configure NAT Instance for Private Subnet Connectivity",
        "description": "Deploy a NAT instance in the public subnet to allow instances in the private subnet to access the internet for updates and package installations.",
        "details": "Create a new file `nat.tf` with the following resources:\n\n```hcl\n# NAT Instance Security Group\nresource \"aws_security_group\" \"nat\" {\n  name        = \"${var.project_name}-nat-sg\"\n  description = \"Security group for NAT instance\"\n  vpc_id      = aws_vpc.main.id\n\n  # Allow all outbound traffic\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  # Allow HTTP/HTTPS from private subnets\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [for subnet in aws_subnet.private : subnet.cidr_block]\n  }\n\n  ingress {\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [for subnet in aws_subnet.private : subnet.cidr_block]\n  }\n\n  # Allow SSH from private subnets\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [for subnet in aws_subnet.private : subnet.cidr_block]\n  }\n\n  tags = {\n    Name = \"${var.project_name}-nat-sg\"\n  }\n}\n\n# Get latest Amazon Linux 2 AMI\ndata \"aws_ami\" \"amazon_linux\" {\n  most_recent = true\n  owners      = [\"amazon\"]\n\n  filter {\n    name   = \"name\"\n    values = [\"amzn2-ami-hvm-*-x86_64-gp2\"]\n  }\n}\n\n# NAT Instance\nresource \"aws_instance\" \"nat\" {\n  ami                    = data.aws_ami.amazon_linux.id\n  instance_type          = \"t3.micro\"\n  subnet_id              = aws_subnet.public[0].id\n  vpc_security_group_ids = [aws_security_group.nat.id]\n  source_dest_check      = false\n  key_name               = aws_key_pair.ssh_key.key_name\n\n  user_data = <<-EOF\n    #!/bin/bash\n    yum update -y\n    echo 1 > /proc/sys/net/ipv4/ip_forward\n    echo \"net.ipv4.ip_forward = 1\" >> /etc/sysctl.conf\n    sysctl -p\n    iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\n    yum install -y iptables-services\n    systemctl enable iptables\n    systemctl start iptables\n    service iptables save\n  EOF\n\n  tags = {\n    Name = \"${var.project_name}-nat-instance\"\n  }\n}\n\n# Route from private subnet to NAT instance\nresource \"aws_route\" \"private_nat\" {\n  route_table_id         = aws_route_table.private.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  instance_id            = aws_instance.nat.id\n}\n```\n\nAdd the following to variables.tf:\n```hcl\nvariable \"ssh_public_key\" {\n  description = \"SSH public key for EC2 instances\"\n  type        = string\n}\n```\n\nCreate a new file `ssh.tf` for the SSH key pair:\n```hcl\nresource \"aws_key_pair\" \"ssh_key\" {\n  key_name   = \"${var.project_name}-key\"\n  public_key = var.ssh_public_key\n}\n```",
        "testStrategy": "Run `terraform plan` to verify the NAT instance configuration. Check that the security group allows traffic from private subnets and that source/destination check is disabled. Verify the route from private subnet to NAT instance is correctly defined.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Deploy Bastion Host with Google Authenticator Setup",
        "description": "Create a bastion host in the public subnet with SSH access and Google Authenticator for two-factor authentication.",
        "details": "Create a new file `bastion.tf` with the following resources:\n\n```hcl\n# Bastion Host Security Group\nresource \"aws_security_group\" \"bastion\" {\n  name        = \"${var.project_name}-bastion-sg\"\n  description = \"Security group for bastion host\"\n  vpc_id      = aws_vpc.main.id\n\n  # Allow SSH from anywhere\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  # Allow all outbound traffic\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = {\n    Name = \"${var.project_name}-bastion-sg\"\n  }\n}\n\n# Bastion Host\nresource \"aws_instance\" \"bastion\" {\n  ami                    = data.aws_ami.amazon_linux.id\n  instance_type          = \"t3.micro\"\n  subnet_id              = aws_subnet.public[0].id\n  vpc_security_group_ids = [aws_security_group.bastion.id]\n  key_name               = aws_key_pair.ssh_key.key_name\n\n  user_data = <<-EOF\n    #!/bin/bash\n    yum update -y\n    amazon-linux-extras install -y epel\n    yum install -y google-authenticator qrencode\n\n    # Create setup script for Google Authenticator\n    cat > /home/ec2-user/setup-google-auth.sh << 'SETUPSCRIPT'\n    #!/bin/bash\n    echo \"Setting up Google Authenticator for SSH 2FA...\"  \n    google-authenticator -t -d -f -r 3 -R 30 -w 3 -s /home/ec2-user/.google_authenticator\n    chmod 400 /home/ec2-user/.google_authenticator\n    echo \"Google Authenticator setup complete. Scan the QR code with your Google Authenticator app.\"  \n    SETUPSCRIPT\n\n    chmod +x /home/ec2-user/setup-google-auth.sh\n    chown ec2-user:ec2-user /home/ec2-user/setup-google-auth.sh\n\n    # Configure SSH to use Google Authenticator\n    echo \"AuthenticationMethods publickey,keyboard-interactive\" >> /etc/ssh/sshd_config\n    echo \"ChallengeResponseAuthentication yes\" >> /etc/ssh/sshd_config\n    echo \"UsePAM yes\" >> /etc/ssh/sshd_config\n    \n    # Configure PAM for SSH to use Google Authenticator\n    sed -i 's/auth       substack     password-auth/auth       required     pam_google_authenticator.so nullok\\nauth       substack     password-auth/' /etc/pam.d/sshd\n    \n    # Restart SSH service\n    systemctl restart sshd\n    \n    # Create instructions file\n    cat > /home/ec2-user/2fa-instructions.txt << 'INSTRUCTIONS'\n    Google Authenticator 2FA Setup Instructions:\n    \n    1. Run the setup script: ./setup-google-auth.sh\n    2. Scan the QR code with your Google Authenticator app\n    3. Save the emergency scratch codes somewhere safe\n    4. For future logins, you will need both your SSH key and a verification code from the app\n    INSTRUCTIONS\n    \n    chown ec2-user:ec2-user /home/ec2-user/2fa-instructions.txt\n  EOF\n\n  tags = {\n    Name = \"${var.project_name}-bastion\"\n  }\n}\n```\n\nAdd the following to outputs.tf:\n```hcl\noutput \"bastion_public_ip\" {\n  description = \"Public IP address of the bastion host\"\n  value       = aws_instance.bastion.public_ip\n}\n\noutput \"bastion_setup_instructions\" {\n  description = \"Instructions for setting up Google Authenticator on the bastion host\"\n  value       = <<-EOT\n    1. SSH into the bastion host: ssh -i your-key.pem ec2-user@${aws_instance.bastion.public_ip}\n    2. Run the setup script: ./setup-google-auth.sh\n    3. Scan the QR code with your Google Authenticator app\n    4. Save the emergency scratch codes somewhere safe\n    5. For future logins, you will need both your SSH key and a verification code from the app\n  EOT\n}\n```",
        "testStrategy": "Run `terraform plan` to verify the bastion host configuration. After applying, test SSH access to the bastion host and verify that the Google Authenticator setup script is available. Run the script and confirm that the QR code is generated and can be scanned with the Google Authenticator app. Test subsequent logins to ensure 2FA is working correctly.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Deploy EC2 Instance with NGINX in Private Subnet",
        "description": "Create an EC2 instance in the private subnet that runs NGINX to serve a simple 'Hello' demo page.",
        "details": "Create a new file `nginx.tf` with the following resources:\n\n```hcl\n# NGINX Instance Security Group\nresource \"aws_security_group\" \"nginx\" {\n  name        = \"${var.project_name}-nginx-sg\"\n  description = \"Security group for NGINX instance\"\n  vpc_id      = aws_vpc.main.id\n\n  # Allow HTTP from anywhere (will be restricted by subnet routing)\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [aws_vpc.main.cidr_block]\n  }\n\n  # Allow SSH from bastion security group\n  ingress {\n    from_port       = 22\n    to_port         = 22\n    protocol        = \"tcp\"\n    security_groups = [aws_security_group.bastion.id]\n  }\n\n  # Allow all outbound traffic\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = {\n    Name = \"${var.project_name}-nginx-sg\"\n  }\n}\n\n# NGINX Instance\nresource \"aws_instance\" \"nginx\" {\n  ami                    = data.aws_ami.amazon_linux.id\n  instance_type          = \"t3.micro\"\n  subnet_id              = aws_subnet.private[0].id\n  vpc_security_group_ids = [aws_security_group.nginx.id]\n  key_name               = aws_key_pair.ssh_key.key_name\n\n  user_data = <<-EOF\n    #!/bin/bash\n    yum update -y\n    amazon-linux-extras install -y nginx1\n    systemctl enable nginx\n    systemctl start nginx\n    \n    # Create a simple hello page\n    cat > /usr/share/nginx/html/index.html << 'HTMLCONTENT'\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <title>Hello from NGINX</title>\n      <style>\n        body {\n          font-family: Arial, sans-serif;\n          margin: 40px;\n          text-align: center;\n        }\n        h1 {\n          color: #333;\n        }\n        .container {\n          max-width: 600px;\n          margin: 0 auto;\n          padding: 20px;\n          border: 1px solid #ddd;\n          border-radius: 5px;\n          background-color: #f9f9f9;\n        }\n      </style>\n    </head>\n    <body>\n      <div class=\"container\">\n        <h1>Hello from NGINX!</h1>\n        <p>This is a simple demo page served by NGINX in a private subnet.</p>\n        <p>AWS Terraform POC is working correctly!</p>\n      </div>\n    </body>\n    </html>\n    HTMLCONTENT\n    \n    # Restart NGINX to apply changes\n    systemctl restart nginx\n  EOF\n\n  tags = {\n    Name = \"${var.project_name}-nginx\"\n  }\n\n  depends_on = [aws_instance.nat]\n}\n```\n\nAdd the following to outputs.tf:\n```hcl\noutput \"nginx_private_ip\" {\n  description = \"Private IP address of the NGINX instance\"\n  value       = aws_instance.nginx.private_ip\n}\n\noutput \"nginx_access_instructions\" {\n  description = \"Instructions for accessing the NGINX demo page\"\n  value       = <<-EOT\n    1. SSH into the bastion host: ssh -i your-key.pem ec2-user@${aws_instance.bastion.public_ip}\n    2. From the bastion, SSH to the NGINX instance: ssh -i your-key.pem ec2-user@${aws_instance.nginx.private_ip}\n    3. Test NGINX locally: curl http://localhost\n    4. Alternatively, set up SSH port forwarding to access from your local browser:\n       ssh -i your-key.pem -L 8080:${aws_instance.nginx.private_ip}:80 ec2-user@${aws_instance.bastion.public_ip}\n       Then open http://localhost:8080 in your browser\n  EOT\n}\n```",
        "testStrategy": "Run `terraform plan` to verify the NGINX instance configuration. After applying, SSH into the bastion host and then to the NGINX instance to verify it's running. Test the NGINX server by using curl from the instance itself. Set up SSH port forwarding and test accessing the NGINX page from a local browser.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Configure Security Group Rules for Controlled Access",
        "description": "Refine security group rules to ensure proper access control between components while maintaining security best practices.",
        "details": "Update the security group configurations in the existing files to ensure proper access control:\n\n1. Update bastion security group in `bastion.tf`:\n```hcl\nresource \"aws_security_group\" \"bastion\" {\n  # Existing configuration...\n  \n  # Restrict SSH to specific IP ranges if needed\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = var.allowed_ssh_cidr_blocks\n  }\n}\n```\n\n2. Update NAT security group in `nat.tf` to allow ICMP for ping tests:\n```hcl\nresource \"aws_security_group\" \"nat\" {\n  # Existing configuration...\n  \n  # Allow ICMP from private subnets for ping tests\n  ingress {\n    from_port   = -1\n    to_port     = -1\n    protocol    = \"icmp\"\n    cidr_blocks = [for subnet in aws_subnet.private : subnet.cidr_block]\n  }\n}\n```\n\n3. Add the following variables to variables.tf:\n```hcl\nvariable \"allowed_ssh_cidr_blocks\" {\n  description = \"CIDR blocks allowed to SSH to the bastion host\"\n  type        = list(string)\n  default     = [\"0.0.0.0/0\"] # Consider restricting this in production\n}\n```\n\nCreate a new file `security.tf` for additional security configurations:\n```hcl\n# Network ACL for public subnets\nresource \"aws_network_acl\" \"public\" {\n  vpc_id     = aws_vpc.main.id\n  subnet_ids = [for subnet in aws_subnet.public : subnet.id]\n\n  # Allow all inbound traffic\n  ingress {\n    protocol   = \"-1\"\n    rule_no    = 100\n    action     = \"allow\"\n    cidr_block = \"0.0.0.0/0\"\n    from_port  = 0\n    to_port    = 0\n  }\n\n  # Allow all outbound traffic\n  egress {\n    protocol   = \"-1\"\n    rule_no    = 100\n    action     = \"allow\"\n    cidr_block = \"0.0.0.0/0\"\n    from_port  = 0\n    to_port    = 0\n  }\n\n  tags = {\n    Name = \"${var.project_name}-public-nacl\"\n  }\n}\n\n# Network ACL for private subnets\nresource \"aws_network_acl\" \"private\" {\n  vpc_id     = aws_vpc.main.id\n  subnet_ids = [for subnet in aws_subnet.private : subnet.id]\n\n  # Allow inbound traffic from VPC CIDR\n  ingress {\n    protocol   = \"-1\"\n    rule_no    = 100\n    action     = \"allow\"\n    cidr_block = aws_vpc.main.cidr_block\n    from_port  = 0\n    to_port    = 0\n  }\n\n  # Allow all outbound traffic\n  egress {\n    protocol   = \"-1\"\n    rule_no    = 100\n    action     = \"allow\"\n    cidr_block = \"0.0.0.0/0\"\n    from_port  = 0\n    to_port    = 0\n  }\n\n  tags = {\n    Name = \"${var.project_name}-private-nacl\"\n  }\n}\n```",
        "testStrategy": "Run `terraform plan` to verify the security group and network ACL configurations. Test connectivity between components to ensure the rules allow the required traffic while blocking unauthorized access. Verify that the bastion host can SSH to the NGINX instance, and that the NGINX instance can access the internet through the NAT instance.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Terraform State Management",
        "description": "Configure remote state storage and locking for Terraform to enable team collaboration and state persistence.",
        "details": "Create a new file `backend.tf` to configure the Terraform backend:\n\n```hcl\n# S3 bucket for Terraform state\nresource \"aws_s3_bucket\" \"terraform_state\" {\n  bucket = var.terraform_state_bucket\n\n  lifecycle {\n    prevent_destroy = true\n  }\n\n  tags = {\n    Name = \"${var.project_name}-terraform-state\"\n  }\n}\n\n# Enable versioning for the S3 bucket\nresource \"aws_s3_bucket_versioning\" \"terraform_state\" {\n  bucket = aws_s3_bucket.terraform_state.id\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\n# DynamoDB table for state locking\nresource \"aws_dynamodb_table\" \"terraform_locks\" {\n  name         = var.terraform_lock_table\n  billing_mode = \"PAY_PER_REQUEST\"\n  hash_key     = \"LockID\"\n\n  attribute {\n    name = \"LockID\"\n    type = \"S\"\n  }\n\n  tags = {\n    Name = \"${var.project_name}-terraform-locks\"\n  }\n}\n```\n\nAdd the following to variables.tf:\n```hcl\nvariable \"terraform_state_bucket\" {\n  description = \"S3 bucket name for Terraform state\"\n  type        = string\n  default     = \"aws-terraform-poc-state\"\n}\n\nvariable \"terraform_lock_table\" {\n  description = \"DynamoDB table name for Terraform state locking\"\n  type        = string\n  default     = \"aws-terraform-poc-locks\"\n}\n```\n\nCreate a separate file `backend_config.tf.example` as a template for the backend configuration:\n```hcl\nterraform {\n  backend \"s3\" {\n    bucket         = \"aws-terraform-poc-state\"\n    key            = \"terraform.tfstate\"\n    region         = \"us-east-1\"\n    dynamodb_table = \"aws-terraform-poc-locks\"\n    encrypt        = true\n  }\n}\n```\n\nAdd instructions in README.md for initializing the backend:\n```markdown\n## Terraform State Management\n\n1. First, deploy the S3 bucket and DynamoDB table:\n   ```\n   terraform init\n   terraform apply -target=aws_s3_bucket.terraform_state -target=aws_dynamodb_table.terraform_locks\n   ```\n\n2. Copy the backend configuration template:\n   ```\n   cp backend_config.tf.example backend_config.tf\n   ```\n\n3. Update the bucket name and region in backend_config.tf if needed\n\n4. Reinitialize Terraform with the backend configuration:\n   ```\n   terraform init -reconfigure\n   ```\n```",
        "testStrategy": "Run `terraform plan` to verify the state management configuration. Apply the S3 bucket and DynamoDB table resources first, then configure the backend and reinitialize Terraform. Verify that the state is stored in the S3 bucket and that locking works by running concurrent Terraform operations.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Create Terraform Modules for Reusable Components",
        "description": "Refactor the Terraform configuration into modules for better organization, reusability, and maintainability.",
        "details": "Create a directory structure for modules:\n\n```\n./\n├── main.tf\n├── variables.tf\n├── outputs.tf\n├── providers.tf\n├── backend.tf\n└── modules/\n    ├── network/\n    │   ├── main.tf\n    │   ├── variables.tf\n    │   └── outputs.tf\n    ├── bastion/\n    │   ├── main.tf\n    │   ├── variables.tf\n    │   └── outputs.tf\n    ├── nat/\n    │   ├── main.tf\n    │   ├── variables.tf\n    │   └── outputs.tf\n    └── nginx/\n        ├── main.tf\n        ├── variables.tf\n        └── outputs.tf\n```\n\nMove the existing resources to their respective modules:\n\n1. Network module (modules/network/main.tf):\n```hcl\n# VPC, subnets, internet gateway, route tables, etc.\n```\n\n2. Bastion module (modules/bastion/main.tf):\n```hcl\n# Bastion host, security group, etc.\n```\n\n3. NAT module (modules/nat/main.tf):\n```hcl\n# NAT instance, security group, etc.\n```\n\n4. NGINX module (modules/nginx/main.tf):\n```hcl\n# NGINX instance, security group, etc.\n```\n\nUpdate the root main.tf to use these modules:\n```hcl\nmodule \"network\" {\n  source = \"./modules/network\"\n  \n  project_name = var.project_name\n  vpc_cidr     = var.vpc_cidr\n}\n\nmodule \"nat\" {\n  source = \"./modules/nat\"\n  \n  project_name        = var.project_name\n  vpc_id              = module.network.vpc_id\n  public_subnet_id    = module.network.public_subnet_ids[0]\n  private_route_table = module.network.private_route_table_id\n  ssh_key_name        = aws_key_pair.ssh_key.key_name\n}\n\nmodule \"bastion\" {\n  source = \"./modules/bastion\"\n  \n  project_name         = var.project_name\n  vpc_id               = module.network.vpc_id\n  public_subnet_id     = module.network.public_subnet_ids[0]\n  ssh_key_name         = aws_key_pair.ssh_key.key_name\n  allowed_ssh_cidr     = var.allowed_ssh_cidr_blocks\n}\n\nmodule \"nginx\" {\n  source = \"./modules/nginx\"\n  \n  project_name      = var.project_name\n  vpc_id            = module.network.vpc_id\n  private_subnet_id = module.network.private_subnet_ids[0]\n  ssh_key_name      = aws_key_pair.ssh_key.key_name\n  bastion_sg_id     = module.bastion.security_group_id\n  vpc_cidr          = var.vpc_cidr\n  \n  depends_on = [module.nat]\n}\n```\n\nUpdate the outputs.tf to reference the module outputs:\n```hcl\noutput \"bastion_public_ip\" {\n  description = \"Public IP address of the bastion host\"\n  value       = module.bastion.public_ip\n}\n\noutput \"nginx_private_ip\" {\n  description = \"Private IP address of the NGINX instance\"\n  value       = module.nginx.private_ip\n}\n\n# Other outputs...\n```",
        "testStrategy": "Run `terraform validate` to ensure the module structure is correct. Run `terraform plan` to verify that the refactored configuration produces the same resources as before. Test applying the configuration and ensure all resources are created correctly and the modules interact properly.",
        "priority": "low",
        "dependencies": [
          2,
          3,
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Comprehensive Documentation",
        "description": "Create detailed documentation for the project, including setup instructions, architecture diagrams, and usage guidelines.",
        "details": "Create a comprehensive README.md file with the following sections:\n\n```markdown\n# AWS Terraform POC\n\nThis project implements a proof of concept (POC) for an AWS infrastructure setup using Terraform. The setup includes a bastion host with Google Authenticator for 2FA, an EC2 instance running an NGINX hello demo in a private subnet, and a NAT instance for connection masquerading.\n\n## Architecture\n\n```\n+------------------+\n|                  |\n|  Internet        |\n|                  |\n+--------+---------+\n         |\n+--------+---------+\n|                  |\n|  Internet        |\n|  Gateway         |\n|                  |\n+--------+---------+\n         |\n+--------+---------+     +------------------+\n|                  |     |                  |\n|  Public Subnet   +-----+  Bastion Host    |\n|                  |     |  (2FA enabled)   |\n+--------+---------+     +------------------+\n         |                        |\n         |                        |\n+--------+---------+     +--------+---------+\n|                  |     |                  |\n|  NAT Instance    |     |  Private Subnet  |\n|                  |     |                  |\n+--------+---------+     +--------+---------+\n         |                        |\n         |                        |\n         |               +--------+---------+\n         |               |                  |\n         +---------------+  NGINX Instance  |\n                         |                  |\n                         +------------------+\n```\n\n## Prerequisites\n\n- AWS account with appropriate permissions\n- Terraform v1.0.0 or newer\n- AWS CLI configured with appropriate credentials\n- SSH key pair for EC2 instances\n- Google Authenticator app installed on your mobile device\n\n## Setup Instructions\n\n1. Clone this repository\n2. Initialize Terraform:\n   ```\n   terraform init\n   ```\n3. Create a `terraform.tfvars` file with your variables:\n   ```\n   aws_region = \"us-east-1\"\n   project_name = \"aws-terraform-poc\"\n   ssh_public_key = \"ssh-rsa AAAA...\" # Your SSH public key\n   allowed_ssh_cidr_blocks = [\"your-ip/32\"]\n   ```\n4. Apply the Terraform configuration:\n   ```\n   terraform apply\n   ```\n5. Follow the output instructions to set up Google Authenticator on the bastion host\n\n## Accessing the NGINX Demo\n\n1. SSH into the bastion host using your SSH key and Google Authenticator code:\n   ```\n   ssh -i your-key.pem ec2-user@<bastion-public-ip>\n   ```\n2. When prompted, enter the verification code from your Google Authenticator app\n3. From the bastion host, SSH to the NGINX instance:\n   ```\n   ssh -i your-key.pem ec2-user@<nginx-private-ip>\n   ```\n4. Test the NGINX server locally:\n   ```\n   curl http://localhost\n   ```\n5. Alternatively, set up SSH port forwarding to access from your local browser:\n   ```\n   ssh -i your-key.pem -L 8080:<nginx-private-ip>:80 ec2-user@<bastion-public-ip>\n   ```\n   Then open http://localhost:8080 in your browser\n\n## Cleanup\n\nTo destroy all resources created by this project:\n```\nterraform destroy\n```\n\n## Security Considerations\n\n- The bastion host is configured with Google Authenticator for 2FA to enhance security\n- The NGINX instance is in a private subnet and not directly accessible from the internet\n- Security groups are configured to allow only necessary traffic\n- Consider restricting SSH access to the bastion host to specific IP addresses in production\n\n## Troubleshooting\n\n- If you can't SSH to the bastion host, check that your SSH key is correct and that your IP is allowed in the security group\n- If you can't access the NGINX instance from the bastion host, check that the NAT instance is running and that the route table is configured correctly\n- If the NGINX instance can't access the internet, check that the NAT instance is properly configured for masquerading\n```\n\nCreate a separate ARCHITECTURE.md file with more detailed information about the infrastructure components and their interactions.\n\nCreate a SETUP.md file with step-by-step instructions for setting up and configuring the infrastructure.",
        "testStrategy": "Review the documentation for completeness and accuracy. Verify that all setup instructions work as described. Have someone unfamiliar with the project follow the documentation to set up the infrastructure and verify that they can successfully complete all steps.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Automated Testing and Validation",
        "description": "Create automated tests and validation scripts to verify the infrastructure is working correctly.",
        "details": "Create a new directory `tests` with the following files:\n\n1. `tests/validate_infrastructure.sh`:\n```bash\n#!/bin/bash\nset -e\n\n# Get outputs from Terraform\nBAST_IP=$(terraform output -raw bastion_public_ip)\nNGINX_IP=$(terraform output -raw nginx_private_ip)\nSSH_KEY=\"$1\"\n\nif [ -z \"$SSH_KEY\" ]; then\n  echo \"Usage: $0 <path-to-ssh-key>\"\n  exit 1\nfi\n\necho \"Testing SSH connection to bastion host...\"\n# This will prompt for Google Authenticator code\nssh -i \"$SSH_KEY\" -o StrictHostKeyChecking=no -o BatchMode=no ec2-user@\"$BAST_IP\" 'echo \"Bastion host connection successful\"'\n\necho \"Testing connection from bastion to NGINX instance...\"\nssh -i \"$SSH_KEY\" -o StrictHostKeyChecking=no ec2-user@\"$BAST_IP\" \"ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ec2-user@$NGINX_IP 'echo \\\"NGINX instance connection successful\\\"'\"\n\necho \"Testing NGINX server...\"\nssh -i \"$SSH_KEY\" -o StrictHostKeyChecking=no ec2-user@\"$BAST_IP\" \"ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ec2-user@$NGINX_IP 'curl -s http://localhost | grep -q \"Hello from NGINX\" && echo \\\"NGINX server is working correctly\\\"'\"\n\necho \"Testing internet connectivity from NGINX instance...\"\nssh -i \"$SSH_KEY\" -o StrictHostKeyChecking=no ec2-user@\"$BAST_IP\" \"ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ec2-user@$NGINX_IP 'ping -c 3 amazon.com && echo \\\"Internet connectivity is working correctly\\\"'\"\n\necho \"All tests passed!\"\n```\n\n2. `tests/setup_port_forwarding.sh`:\n```bash\n#!/bin/bash\nset -e\n\n# Get outputs from Terraform\nBAST_IP=$(terraform output -raw bastion_public_ip)\nNGINX_IP=$(terraform output -raw nginx_private_ip)\nSSH_KEY=\"$1\"\n\nif [ -z \"$SSH_KEY\" ]; then\n  echo \"Usage: $0 <path-to-ssh-key>\"\n  exit 1\nfi\n\necho \"Setting up SSH port forwarding to access NGINX from localhost:8080\"\necho \"When prompted, enter your Google Authenticator code\"\necho \"After connection is established, open http://localhost:8080 in your browser\"\necho \"Press Ctrl+C to terminate the connection when done\"\n\nssh -i \"$SSH_KEY\" -L 8080:\"$NGINX_IP\":80 ec2-user@\"$BAST_IP\"\n```\n\n3. `tests/terraform_validate.sh`:\n```bash\n#!/bin/bash\nset -e\n\necho \"Validating Terraform configuration...\"\nterraform validate\n\necho \"Running terraform plan...\"\nterraform plan -out=tfplan\n\necho \"Checking for errors in plan...\"\nif terraform show -json tfplan | jq -e '.resource_changes[] | select(.change.actions[] | contains(\"delete\"))' > /dev/null; then\n  echo \"WARNING: Plan includes resource deletions!\"\n  terraform show -json tfplan | jq '.resource_changes[] | select(.change.actions[] | contains(\"delete\")) | .address'\n  exit 1\nfi\n\necho \"Terraform configuration is valid!\"\n```\n\nMake the scripts executable:\n```bash\nchmod +x tests/*.sh\n```\n\nAdd a section to the README.md about testing:\n```markdown\n## Testing\n\nThis project includes automated tests to verify the infrastructure is working correctly:\n\n1. Validate the Terraform configuration:\n   ```\n   ./tests/terraform_validate.sh\n   ```\n\n2. Test the infrastructure after deployment:\n   ```\n   ./tests/validate_infrastructure.sh /path/to/your/ssh/key.pem\n   ```\n\n3. Set up port forwarding to access the NGINX server from your local browser:\n   ```\n   ./tests/setup_port_forwarding.sh /path/to/your/ssh/key.pem\n   ```\n```",
        "testStrategy": "Run the validation scripts to verify they correctly test the infrastructure. Verify that the scripts detect and report errors when components are not working correctly. Test the port forwarding script to ensure it correctly sets up access to the NGINX server.",
        "priority": "low",
        "dependencies": [
          4,
          5,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-23T01:53:59.089Z",
      "updated": "2025-07-23T01:53:59.089Z",
      "description": "Tasks for master context"
    }
  }
}